name: Manifest Cache-Bust & Deploy

on:
  push:
    paths:
      - 'addin/manifest.xml'
      - 'addin/*.html'
      - 'addin/*.js'
      - 'addin/*.css'
  workflow_dispatch:
    inputs:
      force_version_increment:
        description: 'Force version increment type'
        required: false
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major

env:
  AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
  AZURE_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
  AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
  AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  CONTAINER_REGISTRY: wellintakeacr0903.azurecr.io
  CONTAINER_APP_NAME: well-intake-api
  RESOURCE_GROUP: TheWell-Infra-East
  API_ENDPOINT: https://well-intake-api.wittyocean-dfae0f9b.eastus.azurecontainerapps.io
  API_KEY: ${{ secrets.API_KEY }}

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      manifest_changed: ${{ steps.changes.outputs.manifest }}
      addin_files_changed: ${{ steps.changes.outputs.addin_files }}
      version_increment: ${{ steps.version.outputs.increment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Detect file changes
        id: changes
        run: |
          if git diff --name-only HEAD^ HEAD | grep -E '^addin/manifest\.xml$'; then
            echo "manifest=true" >> $GITHUB_OUTPUT
          else
            echo "manifest=false" >> $GITHUB_OUTPUT
          fi
          
          if git diff --name-only HEAD^ HEAD | grep -E '^addin/.*\.(html|js|css)$'; then
            echo "addin_files=true" >> $GITHUB_OUTPUT
          else
            echo "addin_files=false" >> $GITHUB_OUTPUT
          fi

      - name: Determine version increment
        id: version
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "increment=${{ github.event.inputs.force_version_increment }}" >> $GITHUB_OUTPUT
          elif [[ "${{ steps.changes.outputs.manifest }}" == "true" ]]; then
            # Major manifest changes
            if git diff HEAD^ HEAD addin/manifest.xml | grep -E '(\+.*<Id>|\+.*<ProviderName>|\+.*<Requirements>)'; then
              echo "increment=major" >> $GITHUB_OUTPUT
            # Minor manifest changes (new features, permissions)
            elif git diff HEAD^ HEAD addin/manifest.xml | grep -E '(\+.*<Permissions>|\+.*<ExtensionPoint>)'; then
              echo "increment=minor" >> $GITHUB_OUTPUT
            else
              echo "increment=patch" >> $GITHUB_OUTPUT
            fi
          else
            echo "increment=patch" >> $GITHUB_OUTPUT
          fi

  increment-version:
    needs: detect-changes
    if: needs.detect-changes.outputs.manifest_changed == 'true' || needs.detect-changes.outputs.addin_files_changed == 'true'
    runs-on: ubuntu-latest
    outputs:
      new_version: ${{ steps.version.outputs.new_version }}
      old_version: ${{ steps.version.outputs.old_version }}
      version_committed: ${{ steps.commit_status.outputs.committed }}
      pr_created: ${{ steps.pr_status.outputs.created }}
      pr_url: ${{ steps.pr_status.outputs.url }}
    permissions:
      contents: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract and increment version
        id: version
        run: |
          # Extract current version from manifest.xml
          CURRENT_VERSION=$(grep -o '<Version>[^<]*</Version>' addin/manifest.xml | sed 's/<Version>//;s/<\/Version>//')
          echo "old_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "Current version: $CURRENT_VERSION"
          
          # Parse semantic version
          IFS='.' read -r major minor patch build <<< "$CURRENT_VERSION"
          
          # Increment based on change type
          case "${{ needs.detect-changes.outputs.version_increment }}" in
            "major")
              major=$((major + 1))
              minor=0
              patch=0
              build=0
              ;;
            "minor")
              minor=$((minor + 1))
              patch=0
              build=0
              ;;
            *)
              # Default to patch increment
              if [[ -z "$build" ]]; then
                build=1
              else
                build=$((build + 1))
              fi
              ;;
          esac
          
          NEW_VERSION="${major}.${minor}.${patch}.${build}"
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "New version: $NEW_VERSION"
          
          # Update manifest.xml with new version
          sed -i "s/<Version>$CURRENT_VERSION<\/Version>/<Version>$NEW_VERSION<\/Version>/g" addin/manifest.xml
          
          # Update cache-busting version parameters in URLs
          sed -i "s/v=$CURRENT_VERSION/v=$NEW_VERSION/g" addin/manifest.xml
          
          # If no version parameter exists, add it
          sed -i 's/\.html"/\.html?v='$NEW_VERSION'"/g' addin/manifest.xml
          sed -i 's/\.html?v=[^"]*"/\.html?v='$NEW_VERSION'"/g' addin/manifest.xml

      - name: Check if we can push to branch
        id: check_push
        run: |
          # Check if this is a PR or protected branch
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            echo "can_push=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Running in PR context - skipping direct push"
          else
            # Try to check if branch is protected
            BRANCH_NAME="${GITHUB_REF#refs/heads/}"
            if [[ "$BRANCH_NAME" == "main" || "$BRANCH_NAME" == "master" ]]; then
              echo "can_push=false" >> $GITHUB_OUTPUT
              echo "‚ö†Ô∏è Protected branch detected - will create PR instead"
            else
              echo "can_push=true" >> $GITHUB_OUTPUT
            fi
          fi

      - name: Commit version changes (direct push)
        id: direct_commit
        if: steps.check_push.outputs.can_push == 'true'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add addin/manifest.xml
          if git commit -m "Auto-increment manifest version to ${{ steps.version.outputs.new_version }} [skip ci]"; then
            git push
            echo "success=true" >> $GITHUB_OUTPUT
          else
            echo "No changes to commit"
            echo "success=false" >> $GITHUB_OUTPUT
          fi

      - name: Create version branch and PR
        id: create_pr
        if: steps.check_push.outputs.can_push == 'false'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Create a new branch for the version update
          BRANCH_NAME="ci/manifest-version-${{ steps.version.outputs.new_version }}"
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git checkout -b "$BRANCH_NAME"
          git add addin/manifest.xml
          git commit -m "Auto-increment manifest version to ${{ steps.version.outputs.new_version }} [skip ci]" || exit 0
          git push origin "$BRANCH_NAME"

          # Create PR using GitHub CLI
          PR_URL=$(gh pr create \
            --title "Auto-increment manifest version to ${{ steps.version.outputs.new_version }}" \
            --body "This PR auto-increments the manifest version from ${{ steps.version.outputs.old_version }} to ${{ steps.version.outputs.new_version }}\n\n‚ö†Ô∏è **Important**: Deployment is blocked until this PR is merged.\n\nTriggered by: ${{ github.event_name }}\nCommit: ${{ github.sha }}" \
            --base "${GITHUB_REF#refs/heads/}" \
            --head "$BRANCH_NAME" 2>&1 | grep -o 'https://[^ ]*' || echo "")

          if [[ -n "$PR_URL" ]]; then
            echo "pr_url=$PR_URL" >> $GITHUB_OUTPUT
            echo "created=true" >> $GITHUB_OUTPUT
            echo "‚úÖ PR created: $PR_URL"
          else
            echo "created=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è PR creation failed or already exists"
          fi

      - name: Set commit status output
        id: commit_status
        run: |
          if [[ "${{ steps.check_push.outputs.can_push }}" == "true" ]] && [[ "${{ steps.direct_commit.outputs.success }}" == "true" ]]; then
            echo "committed=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Version committed to current branch"
          else
            echo "committed=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Version not committed to current branch - deployment will be skipped"
          fi

      - name: Set PR status output
        id: pr_status
        run: |
          if [[ "${{ steps.check_push.outputs.can_push }}" == "false" ]]; then
            echo "created=${{ steps.create_pr.outputs.created }}" >> $GITHUB_OUTPUT
            echo "url=${{ steps.create_pr.outputs.pr_url }}" >> $GITHUB_OUTPUT
          else
            echo "created=false" >> $GITHUB_OUTPUT
            echo "url=" >> $GITHUB_OUTPUT
          fi

  clear-cache:
    needs: [detect-changes, increment-version]
    if: |
      (needs.detect-changes.outputs.manifest_changed == 'true' || needs.detect-changes.outputs.addin_files_changed == 'true') &&
      needs.increment-version.outputs.version_committed == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Clear Redis cache
        run: |
          echo "Clearing Redis cache for manifest and add-in files..."
          
          # Clear cache via API endpoint
          curl -X POST "${{ env.API_ENDPOINT }}/cache/invalidate" \
            -H "X-API-Key: ${{ env.API_KEY }}" \
            -H "Content-Type: application/json" \
            -d '{"pattern": "manifest:*,addin:*,taskpane:*"}' \
            --max-time 30 \
            --retry 3 \
            --fail-with-body || echo "Cache clear failed, continuing..."
          
          # Additional cache warming patterns
          curl -X POST "${{ env.API_ENDPOINT }}/cache/warmup" \
            -H "X-API-Key: ${{ env.API_KEY }}" \
            -H "Content-Type: application/json" \
            -d '{"patterns": ["manifest.xml", "taskpane.html", "commands.html"]}' \
            --max-time 30 \
            --retry 3 \
            --fail-with-body || echo "Cache warmup failed, continuing..."

  check-credentials:
    needs: [detect-changes, increment-version]
    if: |
      (needs.detect-changes.outputs.manifest_changed == 'true' || needs.detect-changes.outputs.addin_files_changed == 'true') &&
      needs.increment-version.outputs.version_committed == 'true'
    runs-on: ubuntu-latest
    outputs:
      has_azure_creds: ${{ steps.check.outputs.has_creds }}
    steps:
      - name: Check Azure credentials
        id: check
        run: |
          if [[ -n "${{ env.AZURE_CLIENT_ID }}" && \
                -n "${{ env.AZURE_CLIENT_SECRET }}" && \
                -n "${{ env.AZURE_TENANT_ID }}" && \
                -n "${{ env.AZURE_SUBSCRIPTION_ID }}" ]]; then
            echo "has_creds=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Azure credentials are configured"
          else
            echo "has_creds=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Azure credentials are missing. Deployment will be skipped."
            echo "To enable deployment, set the following secrets in your repository:"
            echo "  - AZURE_CLIENT_ID"
            echo "  - AZURE_CLIENT_SECRET"
            echo "  - AZURE_TENANT_ID"
            echo "  - AZURE_SUBSCRIPTION_ID"
          fi

  build-and-deploy:
    needs: [detect-changes, increment-version, clear-cache, check-credentials]
    if: |
      (needs.detect-changes.outputs.manifest_changed == 'true' || needs.detect-changes.outputs.addin_files_changed == 'true') &&
      needs.check-credentials.outputs.has_azure_creds == 'true' &&
      needs.increment-version.outputs.version_committed == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.sha }}

      - name: Pull latest changes
        run: |
          git pull origin ${{ github.ref_name }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Azure
        uses: azure/login@v1
        with:
          creds: |
            {
              "clientId": "${{ env.AZURE_CLIENT_ID }}",
              "clientSecret": "${{ env.AZURE_CLIENT_SECRET }}",
              "subscriptionId": "${{ env.AZURE_SUBSCRIPTION_ID }}",
              "tenantId": "${{ env.AZURE_TENANT_ID }}"
            }

      - name: Log in to Azure Container Registry
        run: |
          az acr login --name wellintakeacr0903

      - name: Build and push Docker image
        env:
          IMAGE_TAG: ${{ needs.increment-version.outputs.new_version }}-${{ github.sha }}
        run: |
          # Build multi-platform image
          docker buildx build \
            --platform linux/amd64 \
            --tag ${{ env.CONTAINER_REGISTRY }}/well-intake-api:${{ env.IMAGE_TAG }} \
            --tag ${{ env.CONTAINER_REGISTRY }}/well-intake-api:latest \
            --push \
            --cache-from type=registry,ref=${{ env.CONTAINER_REGISTRY }}/well-intake-api:cache \
            --cache-to type=registry,ref=${{ env.CONTAINER_REGISTRY }}/well-intake-api:cache,mode=max \
            .

      - name: Deploy to Azure Container Apps
        env:
          IMAGE_TAG: ${{ needs.increment-version.outputs.new_version }}-${{ github.sha }}
        run: |
          echo "Deploying image with tag: ${{ env.IMAGE_TAG }}"
          
          # Update container app with new image
          az containerapp update \
            --name ${{ env.CONTAINER_APP_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --image ${{ env.CONTAINER_REGISTRY }}/well-intake-api:${{ env.IMAGE_TAG }} \
            --output table
          
          # Wait for deployment to complete
          echo "Waiting for deployment to complete..."
          for i in {1..30}; do
            STATUS=$(az containerapp show \
              --name ${{ env.CONTAINER_APP_NAME }} \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --query "properties.provisioningState" \
              --output tsv)
            
            if [[ "$STATUS" == "Succeeded" ]]; then
              echo "Deployment completed successfully"
              break
            elif [[ "$STATUS" == "Failed" ]]; then
              echo "Deployment failed"
              exit 1
            fi
            
            echo "Deployment status: $STATUS (attempt $i/30)"
            sleep 10
          done

  post-deployment:
    needs: [increment-version, build-and-deploy, check-credentials]
    if: |
      needs.check-credentials.outputs.has_azure_creds == 'true' &&
      needs.increment-version.outputs.version_committed == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Wait for service to be ready
        run: |
          echo "Waiting for service to be ready..."
          for i in {1..20}; do
            if curl -f "${{ env.API_ENDPOINT }}/health" --max-time 10; then
              echo "Service is healthy"
              break
            fi
            echo "Health check failed, retrying in 15 seconds... (attempt $i/20)"
            sleep 15
          done

      - name: Verify manifest accessibility
        run: |
          echo "Verifying manifest accessibility..."
          
          # Test manifest.xml with new version
          MANIFEST_URL="${{ env.API_ENDPOINT }}/manifest.xml?v=${{ needs.increment-version.outputs.new_version }}"
          echo "Testing manifest URL: $MANIFEST_URL"
          
          if curl -f "$MANIFEST_URL" --max-time 30; then
            echo "‚úÖ Manifest is accessible with new version"
          else
            echo "‚ùå Manifest accessibility test failed"
            exit 1
          fi
          
          # Test taskpane.html with new version
          TASKPANE_URL="${{ env.API_ENDPOINT }}/taskpane.html?v=${{ needs.increment-version.outputs.new_version }}"
          echo "Testing taskpane URL: $TASKPANE_URL"
          
          if curl -f "$TASKPANE_URL" --max-time 30; then
            echo "‚úÖ Taskpane is accessible with new version"
          else
            echo "‚ùå Taskpane accessibility test failed"
            exit 1
          fi

      - name: Warm cache with new manifest
        run: |
          echo "Warming cache with new manifest version..."
          
          curl -X POST "${{ env.API_ENDPOINT }}/cache/warmup" \
            -H "X-API-Key: ${{ env.API_KEY }}" \
            -H "Content-Type: application/json" \
            -d '{
              "patterns": [
                "manifest.xml?v=${{ needs.increment-version.outputs.new_version }}",
                "taskpane.html?v=${{ needs.increment-version.outputs.new_version }}",
                "commands.html?v=${{ needs.increment-version.outputs.new_version }}"
              ]
            }' \
            --max-time 30 \
            --retry 3 \
            --fail-with-body || echo "Cache warming completed with warnings"

      - name: Run smoke tests
        run: |
          echo "Running smoke tests..."
          
          # Test health endpoint
          curl -f "${{ env.API_ENDPOINT }}/health" || exit 1
          
          # Test manifest endpoint
          curl -f "${{ env.API_ENDPOINT }}/manifest.xml" || exit 1
          
          # Test static assets
          curl -f "${{ env.API_ENDPOINT }}/icon-64.png" || exit 1
          
          echo "‚úÖ All smoke tests passed"

  notify:
    needs: [increment-version, build-and-deploy, post-deployment, check-credentials]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Notify deployment result
        run: |
          # Check if version commit was skipped due to protected branch
          if [[ "${{ needs.increment-version.outputs.version_committed }}" != "true" ]]; then
            echo "‚ö†Ô∏è Deployment skipped: Version changes not committed to current branch"
            echo ""
            if [[ "${{ needs.increment-version.outputs.pr_created }}" == "true" ]]; then
              echo "üìù A pull request has been created with the version changes:"
              echo "   ${{ needs.increment-version.outputs.pr_url }}"
              echo ""
              echo "‚û°Ô∏è Next steps:"
              echo "   1. Review and merge the PR"
              echo "   2. The deployment will run automatically after merge"
            else
              echo "‚ùå Failed to create PR for version changes"
              echo "   Please manually update the manifest version and retry"
            fi
            exit 0
          fi

          # Check if deployment was skipped due to missing credentials
          if [[ "${{ needs.check-credentials.outputs.has_azure_creds }}" != "true" ]]; then
            echo "‚ö†Ô∏è Deployment skipped: Azure credentials not configured"
            echo "Version was updated but not deployed to Azure."
            echo "Configure the required secrets to enable automatic deployment."
            exit 0
          fi

          if [[ "${{ needs.post-deployment.result }}" == "success" ]]; then
            echo "üéâ Deployment successful!"
            echo "üì¶ Version: ${{ needs.increment-version.outputs.old_version }} ‚Üí ${{ needs.increment-version.outputs.new_version }}"
            echo "üîó Manifest URL: ${{ env.API_ENDPOINT }}/manifest.xml?v=${{ needs.increment-version.outputs.new_version }}"
            echo "üåê API Health: ${{ env.API_ENDPOINT }}/health"
            echo "üìã Cache Status: ${{ env.API_ENDPOINT }}/cache/status"
          else
            echo "‚ùå Deployment failed or was cancelled"
            echo "üîç Check the workflow logs for details"
            echo "üîÑ Consider running the workflow manually with force_version_increment"
          fi

  rollback:
    needs: [increment-version, build-and-deploy, post-deployment, check-credentials]
    if: |
      failure() &&
      needs.increment-version.outputs.old_version != '' &&
      needs.check-credentials.outputs.has_azure_creds == 'true' &&
      needs.increment-version.outputs.version_committed == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Log in to Azure
        uses: azure/login@v1
        with:
          creds: |
            {
              "clientId": "${{ env.AZURE_CLIENT_ID }}",
              "clientSecret": "${{ env.AZURE_CLIENT_SECRET }}",
              "subscriptionId": "${{ env.AZURE_SUBSCRIPTION_ID }}",
              "tenantId": "${{ env.AZURE_TENANT_ID }}"
            }

      - name: Rollback to previous version
        run: |
          echo "Rolling back to version ${{ needs.increment-version.outputs.old_version }}"
          
          # Revert manifest version
          sed -i "s/<Version>${{ needs.increment-version.outputs.new_version }}<\/Version>/<Version>${{ needs.increment-version.outputs.old_version }}<\/Version>/g" addin/manifest.xml
          sed -i "s/v=${{ needs.increment-version.outputs.new_version }}/v=${{ needs.increment-version.outputs.old_version }}/g" addin/manifest.xml
          
          # Check if we can push rollback
          BRANCH_NAME="${GITHUB_REF#refs/heads/}"
          if [[ "${{ github.event_name }}" == "pull_request" || "$BRANCH_NAME" == "main" || "$BRANCH_NAME" == "master" ]]; then
            echo "‚ö†Ô∏è Cannot push rollback to protected branch - manual intervention required"
            echo "Please manually revert the manifest version to ${{ needs.increment-version.outputs.old_version }}"
          else
            # Commit rollback
            git config --local user.email "action@github.com"
            git config --local user.name "GitHub Action"
            git add addin/manifest.xml
            git commit -m "Rollback manifest version to ${{ needs.increment-version.outputs.old_version }} [skip ci]"
            git push
          fi
          
          # Try to rollback container deployment (best effort)
          PREVIOUS_IMAGE=$(az containerapp revision list \
            --name ${{ env.CONTAINER_APP_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --query "[1].properties.template.containers[0].image" \
            --output tsv 2>/dev/null || echo "")
          
          if [[ -n "$PREVIOUS_IMAGE" ]]; then
            echo "Attempting to rollback to previous image: $PREVIOUS_IMAGE"
            az containerapp update \
              --name ${{ env.CONTAINER_APP_NAME }} \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --image "$PREVIOUS_IMAGE" \
              --output table || echo "Container rollback failed"
          fi
          
          echo "üîÑ Rollback completed. Manual intervention may be required."